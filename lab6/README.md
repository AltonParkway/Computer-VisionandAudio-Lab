# 介绍

课程的最后一个实验是处理雀斑，网上查找了很多方法，最后我选择了快速双边滤波。但是实验又不能直接调用 opencv 的库，因此，我参照了 [这个博客](httpswww.cnblogs.comwangguchangqingp6416401.htmltdsourcetag=s_pcqq_aiomsg)，将用 C 写的快速双边滤波改用 Python 重新写了一遍。

快速双边滤波是啥呢，官方滴说，它是一种非线性的滤波方法。它最大的特点就是既使用了颜色的相似度，又利用了空间的距离相似度。也就是说，它在进行滤波的过程中，不光要考虑周围像素值与中点像素值的大小之差，还需要考虑空间上的距离，进而确定该点对中间点的影响因子。

 至于为啥要用快速双边滤波呢，，因为不优化的话，实在是太慢了。。。有兴趣可以试一下。


#   计算公式

刚刚已经讲过原理了，现在看一下它的计算过程。

它主要分为两大部分，一个是计算颜色值的相似度，公式如下：

$$r(i,j,k,l) = exp(-frac{f(i,j) - f(k,l)^2}{2sigma_r^2})$$

另一个是计算空间距离的相似度，也就是说，离得越近，相似度越高。公式如下：

$$d(i,j,k,l) = exp(-frac{(i-k)^2 + (j-l)^2}{2sigma_d^2})$$

这里的 （i, j）代表要处理的像素点的坐标，（k，l）则是其周围一定范围内，可能影响到其值的像素点的坐标。千万不要被一堆字母搞晕了，逻辑还是挺清晰的。

总体公式如下：

$$w(i,j,k,l) = d(i,j,k,l)  r(i,j,k,l) = exp(-frac{(i-k)^2 + (j-l)^2}{2sigma_d^2} - frac{f(i,j) - f(k,l)^2}{2sigma_r^2})$$

  $f(x,y)$ 表示要处理的图像，f(x,y)表示图像在点(x,y)处的像素值
 $(k,l)$为模板窗口的中心坐标
 $(i,j)$为模板窗口的其他系数的坐标；
 $sigma_r$为高斯函数的标准差

这个就是矩阵中，像素点的系数。

# 优化代码

主要的优化部分有三个：

1. 空间距离的系数（$d(i,j,l,k)$）与像素点的值无关，只与矩阵的大小有关，因此可以首先将它计算出来，需要的时候再去查找。
2. 其次就是灰度值的计算，由于像素点过多，每次滤波，逐个计算的计算量特别大；而像素点的值只是在（0,255）区间内，因此，也可以使用查表的方式进行查找，这样只是（0,$255^2$）上面进行查找即可，不需要挨个计算。
3. 将二维的模板转换为一维，降低算法复杂度。（就是更改了一下索引的方式）

具体的 C 语音实现，还需要看文章开始的那篇博客，这里再粘贴一下：

[图像处理基础(5)：双边滤波器](httpswww.cnblogs.comwangguchangqingp6416401.htmltdsourcetag=s_pcqq_aiomsg)

# 总结

三个维度的滤波不应该像我这样写，应该一起处理，我分成了三个通道进行处理，代码就显得有点长，但这样十分方便，如果有时间的话，还是不要像我这样写。

需要注意的一点是，这段代码在处理图片的效果上不是很好，相比于 opencv 的库，效果差了很多，尤其是处理大图片的时候，使用时需要注意。
