# 空域滤波介绍

空域也叫空间域，是一种像素级上的操作，即直接对图像上的像素值进行增加或减少。对应的另一种图像处理的操作，是频域上的操作，频域可以由空域通过傅里叶变换转换过来，它更能体现图像中的能量特征。

处理图像的常用方法就是对图像进行滤波处理，即对图像的频率进行过滤，通常的滤波方法分为两种：**高通滤波和低通滤波**。顾名思义，高通滤波就是，减弱或阻隔低频信号，保留高频信号；而相应的，低通滤波是，减弱或阻隔高频信号，保留低频信号。虽然空域是图像在空间坐标的表示，但无论是空域还是频域，滤波都是处理图像的频率。

空域滤波按照过滤频率的高低，分为**平滑（模糊）和锐化**，平滑对应低通滤波；锐化对应高通滤波。也可以按照滤波的算法，分为**线性滤波和非线性滤波**，线性滤波就是滤波过程中，对像素的处理是线性的，如加减乘除等；而非线性滤波就是像素的处理是非线性的，如取最大值、取中值等。

空域滤波通常的方法是：**取一个模板，然后平移这个模板，每次平移，都将进行一次计算，将计算的结果赋予给模板中间的像素，代替其原来的值，从而达到滤波的效果**。空域中，不同的滤波方法就对应了不同的模板选取方式和模板中的计算方式。空域滤波器，可以看成一个函数，即算子，可以将一个像素值映射为另一个像素值。

# 低通滤波

## 邻域平均法

邻域平均法，顾名思义，就是**邻域内各点灰度均值代替该点的像素值**，也可以称为均值滤波。这是最简单，也是最常用的滤波方式。

![均值滤波模板](https://img-blog.csdnimg.cn/20190227195619382.png)

在这上面进行扩展，可能会得到更有效的滤波器，例如增加阈值（取阈值的邻域平均法）：某像素的灰度大于其邻近像素的 平均灰度，并超过阈值 T ，用均值替代。

公式如下：

![取阈值的邻域平均法](https://img-blog.csdnimg.cn/20190227200001325.png)

效果：

![均值滤波效果](https://img-blog.csdnimg.cn/20190227200107951.png)

此外，也可以更改模板中的权值，变为邻域加权平均，例如：

$H =  \frac1{16}\begin{bmatrix} 1 & 2 & 1 \\ 2 & 4 & 2 \\ 1 & 2 & 1\end{bmatrix}$

注意： 

**为了保证邻域中的平均灰度在处理前后保持不变，权矩阵（模板）中各个元素的权值之和必须等于1。**

## 中值滤波

这是一种非线性的处理技术，可用来抑制图像中的噪声而不使边缘模糊。 

原理很简单：**取一移动窗口，上下左右移动，用窗口内的像素（奇 数个）的中值代替窗口中心像素的灰度。**

![中值滤波例子1](https://img-blog.csdnimg.cn/20190227224220490.png)

![中值滤波例子2](https://img-blog.csdnimg.cn/20190227224253244.png)

需要注意的是，**中值滤波适合去除椒盐噪声，均值滤波适合去除高斯噪声。**

# 高通滤波

高通滤波也就是锐化处理，通常是用于把图像变得更清晰，突出细节或是用于检测图像边缘。

锐化操作的模板矩阵通常带有负值，这样才能增大边缘之间的像素差，突出图像边缘特征。

下面用两个算子分别对同一张图片进行锐化处理：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190227231819286.jpg)

## Roberts算子

Roberts 算子是利用的局部像素差来进行边缘检测。是 2*2 窗口的，利用对角线相邻像素之差来进行检测。矩阵变化如下：

![Roberts算子](https://img-blog.csdnimg.cn/20190227231925808.png)

效果：

![Roberts算子效果](https://img-blog.csdnimg.cn/20190227232146898.png)

分别是蓝绿红三个通道的边缘和总的效果。

## Sobel 算子

Sobel 算子是对阶跃边缘，对数字图像{f(i,j)}的每个像素，考察它上、下、左、右邻点 灰度的加权差。与之接近的邻点权大。

该算子是 3*3 窗口的，变换矩阵如下：

![Sobel 算子](https://img-blog.csdnimg.cn/20190227232031544.png)

结果：

![Sobel 算子效果](https://img-blog.csdnimg.cn/20190227232338144.png)

# 快速中值滤波

## 原理
中值滤波是空域中常用的一种滤波方式，是一种非线性的滤波。它的原理就是**将窗口像素排序，取中值，然后移动窗口，不断重复取中值的过程**。

但是，可以发现，每次移动窗口，都需要对像素点进行排序，从而选取中间的那个像素点。每次重新排序的效率特别低，为了优化这个排序，便有了快速中值滤波。

快速中值滤波是中值滤波的优化版，它利用了窗口每次平移时，没有移出窗口的像素点还是排好序的，因此，只需要把新加入的像素点插入到其中即可完成排序。此外，由于我们并不需要一个完整的排序数列， 只需要找到中值就可以了。

基于上面两点，快速中值滤波采用的是**直方图**的方式来统计像素点，横坐标是像素点的值，纵坐标是窗口中像素点的个数。设置一个“光标”，在横轴上左右移动，当两边像素点相等时，对应的像素点就是要找的中值。然后移动窗口，更新直方图，再次移动“光标”，找到中值，不断反复。

需要注意的是，**“光标”的每次移动，都只能移动在数目不为 0 的像素点上**，否则，取到的中值很可能不在这个窗口中。

## 步骤

* 第一步：
设置门限th = N*M/2。门限是用来判断像素点是否是中值的，它是窗口大小的一半，如果不知道有啥用，看第五步的用法。

* 第二步：
将窗口移动到一个新行的开始，建立窗口像素的直方图，通过直方图确定中值 med，记下亮度小于或等于 med 的像素数目到变量 n 中。

* 第三步：
对于最左列的每个像素，去掉每一个元素，并将直方图中的相应的数值更新，然后更新n的值。

* 第四步：
同理，与第三步一样，对于最右列的每个像素，增加每一个元素的值，并将直方图中的相应的数值进行更新。

* 第五步：
然后判断n的值与门限 th 的大小。如果 n > th，则将 med 进行递减操作；如果n < th 则将 med 进行递增操作。直到 n 超过 th 为止。得到的 med 就是需要的中值。
